<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Clasificador EmoLex Demo</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; }
    textarea { width: 100%; height: 80px; margin-top: 0.5em;}
    table { margin-top:2em; border-collapse:collapse; width:100%;}
    th, td { border:1px solid #aaa; padding:0.3em 0.5em; text-align:center;}
    th { background:#f2f2f2; }
    #status {margin-top:2em;}
    button { margin-top:1em; }
  </style>
</head>
<body>
  <h2>Clasificador EmoLex Demo (Emociones léxicas automáticas)</h2>
  <form id="input-form">
    <label>
      Ingresa palabras (separadas por coma o salto de línea):
      <textarea id="input-words" required placeholder="alegría, tristeza, miedo"></textarea>
    </label>
    <button type="submit">Clasificar palabras</button>
  </form>

  <div id="results-container" style="display:none;">
    <h3>Resultados:</h3>
    <table id="results-table">
      <thead>
        <tr>
          <th>Word</th>
          <th>Cluster</th>
          <th>Sub-Cluster</th>
          <th>BIS</th>
          <th>Valence</th>
          <th>Arousal</th>
          <th>Concreteness</th>
          <th>Emotionality</th>
          <th>Dominant_emotion</th>
          <th>Zipf_EsPal</th>
          <th>POS</th>
          <th>F1 Score</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <button id="send-to-sheet">Enviar todos los resultados a Google Sheet</button>
  </div>
  <div id="status"></div>

  <script>
    // === Simulación de un "mini-lexicon" ===
    // Reemplaza este objeto por tu tabla real de palabras o conexión a modelo RF exportado a JS
    const LEXICON = {
      "alegría": {
        Cluster: 0, "Sub-Cluster": 1, BIS: 0.0023, Valence_Mean: 7.8, Arousal_Mean: 6.3, Concreteness_Mean: 4.1,
        Emotionality: 0.96, Dominant_emotion: "joy", Zipf_EsPal: 5.7, POS: "noun", F1: 0.95
      },
      "tristeza": {
        Cluster: 1, "Sub-Cluster": 2, BIS: 0.0011, Valence_Mean: 2.1, Arousal_Mean: 3.2, Concreteness_Mean: 4.2,
        Emotionality: 0.89, Dominant_emotion: "sadness", Zipf_EsPal: 5.5, POS: "noun", F1: 0.91
      },
      "miedo": {
        Cluster: 1, "Sub-Cluster": 2, BIS: 0.0018, Valence_Mean: 2.5, Arousal_Mean: 6.5, Concreteness_Mean: 4.0,
        Emotionality: 0.92, Dominant_emotion: "fear", Zipf_EsPal: 5.6, POS: "noun", F1: 0.92
      }
      // ...agrega más palabras reales aquí
    };

    // Endpoint real de SheetDB
    const SHEETDB_ENDPOINT = "https://sheetdb.io/api/v1/uh85eupspafxg";

    let lastResults = [];

    document.getElementById("input-form").addEventListener("submit", function(e){
      e.preventDefault();
      const input = document.getElementById("input-words").value;
      const words = input.split(/[\s,]+/).map(w=>w.trim().toLowerCase()).filter(Boolean);
      const results = classifyWords(words);
      lastResults = results;
      renderResults(results);
      document.getElementById("results-container").style.display = "block";
      document.getElementById("status").textContent = "";
    });

    function classifyWords(words) {
      // Aquí puedes conectar tu modelo real o usar un fetch a un API
      return words.map(word => {
        const entry = LEXICON[word] || {};
        // Si la palabra no existe, usar valores vacíos/null
        return {
          Word: word,
          Cluster: entry.Cluster ?? "N/A",
          "Sub-Cluster": entry["Sub-Cluster"] ?? "N/A",
          Balanced_Integration_Score: entry.BIS ?? "",
          Valence_Mean: entry.Valence_Mean ?? "",
          Arousal_Mean: entry.Arousal_Mean ?? "",
          Concreteness_Mean: entry.Concreteness_Mean ?? "",
          Emotionality: entry.Emotionality ?? "",
          Dominant_emotion: entry.Dominant_emotion ?? "",
          Zipf_EsPal: entry.Zipf_EsPal ?? "",
          POS: entry.POS ?? "",
          F1: entry.F1 ?? "",
          userID: ""
        };
      });
    }

    function renderResults(results) {
      const tbody = document.querySelector("#results-table tbody");
      tbody.innerHTML = "";
      for (const r of results) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${r.Word}</td>
          <td>${r.Cluster}</td>
          <td>${r["Sub-Cluster"]}</td>
          <td>${r.Balanced_Integration_Score}</td>
          <td>${r.Valence_Mean}</td>
          <td>${r.Arousal_Mean}</td>
          <td>${r.Concreteness_Mean}</td>
          <td>${r.Emotionality}</td>
          <td>${r.Dominant_emotion}</td>
          <td>${r.Zipf_EsPal}</td>
          <td>${r.POS}</td>
          <td>${r.F1}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    document.getElementById("send-to-sheet").addEventListener("click", function() {
      if (!lastResults.length) return;
      document.getElementById("status").textContent = "Enviando datos a Google Sheet...";
      Promise.all(lastResults.map(row => sendToSheetDB(row)))
        .then(() => {
          document.getElementById("status").textContent = "¡Todos los resultados fueron enviados!";
        })
        .catch(err => {
          document.getElementById("status").textContent = "Error al enviar: " + err;
        });
    });

    function sendToSheetDB(row) {
      // SheetDB requiere un objeto { data: { ... } }
      const payload = { data: { ...row, timestamp: new Date().toISOString() } };

      return fetch(SHEETDB_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=UTF-8" },
        body: JSON.stringify(payload)
      })
      .then(r => r.json());
    }
  </script>
</body>
</html>
