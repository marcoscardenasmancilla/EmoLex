<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Clasificador EmoLex - Calculator</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; background: #f7f9fb;}
    .emolex-section { margin-bottom: 2em; background: #fff; border-radius: 8px; box-shadow: 0 1px 8px #ddd; padding: 2em; }
    .emolex-table { width: 100%; border-collapse: collapse; }
    .emolex-table th, .emolex-table td { border: 1px solid #bbb; padding: 0.5em; text-align: center; }
    .emolex-table th { background: #e8f1fa; }
    #input-words, #word-select { width: 100%; height: 2.5em; margin-bottom: 1em; font-size: 1em; }
    button { padding: 0.5em 2em; font-size: 1em; background: #1a7fd7; color: #fff; border: none; border-radius: 5px; }
    #status { margin-top: 1em; color: #248c3c; font-weight: bold;}
    .warn { color:#a00; font-weight: bold; }
    details { margin-top: 1em; }
    summary { font-weight: bold; }
    @media (max-width: 700px) {
      .emolex-section { padding: 1em; }
      .emolex-table th, .emolex-table td { font-size: 0.95em; }
    }
  </style>
  <script src="functions.js"></script>
</head>
<body>
  <div class="emolex-section">
    <h2>Clasificador EmoLex (Calculator)</h2>
    <p>
      Selecciona una palabra clasificada del léxico, o ingresa una palabra para buscar su clasificación.<br>
      <small>(Solo se clasificarán palabras presentes en la base léxica validada).</small>
    </p>
  </div>

  <!-- Panel de selección desplegable -->
  <div class="emolex-section">
    <label for="word-select"><b>Selecciona una palabra:</b></label>
    <select id="word-select">
      <option value="">-- Elige una palabra --</option>
    </select>
    <div id="select-status"></div>
  </div>

  <!-- Entrada manual -->
  <form id="input-form" class="emolex-section" autocomplete="off">
    <label for="input-words"><strong>O ingresa una palabra:</strong></label>
    <input id="input-words" type="text" placeholder="Ejemplo: alegría">
    <button type="submit">Buscar y clasificar</button>
    <span id="manual-status"></span>
  </form>

  <div class="emolex-section" id="results-panel" style="display:none;">
    <h3>Resultados</h3>
    <table id="results-table" class="emolex-table">
      <thead>
        <tr>
          <th>Palabra</th>
          <th>Cluster</th>
          <th>Sub-Cluster</th>
          <th>BIS</th>
          <th>Valencia</th>
          <th>Activación</th>
          <th>Concreción</th>
          <th>Emocionalidad</th>
          <th>Emoción dominante</th>
          <th>Frecuencia (Zipf)</th>
          <th>POS</th>
          <th>F1-score<br>(crossval)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="emolex-section" id="summary-stats" style="display:none;">
    <h3>Resumen estadístico (solo para selección múltiple)</h3>
  </div>

  <div id="comparative-panel" class="emolex-section" style="display:none;"></div>

  <details class="emolex-section">
    <summary>¿Cómo interpretar estos resultados?</summary>
    <ul>
      <li><b>Cluster/Sub-Cluster:</b> agrupación emocional asignada por el modelo.</li>
      <li><b>BIS:</b> índice de complejidad/prototipicidad léxica.</li>
      <li><b>F1-score:</b> confiabilidad de la predicción (validación cruzada del modelo RF).</li>
      <li><b>IC 95%:</b> intervalo de confianza, robustez de las estimaciones (solo para selección múltiple).</li>
      <li><b>Comparativa BIS:</b> muestra la diferencia de complejidad léxica entre subclústeres usando Cohen's d y Hedges’ g.</li>
    </ul>
  </details>

  <script>
    // F1 POR SUB-CLUSTER (del log crossval)
    const F1_by_subcluster = { 1:0.832, 2:0.961, 3:0.943, 4:0.920 };

    // LEXICON dinámico
    let LEXICON = {};
    let wordList = [];
    fetch('lexicon.json')
      .then(response => response.json())
      .then(data => {
        LEXICON = {};
        wordList = [];
        data.forEach(entry => {
          const w = entry.Word.toLowerCase();
          LEXICON[w] = entry;
          wordList.push(w);
        });
        populateWordSelect();
      });

    function populateWordSelect() {
      const select = document.getElementById("word-select");
      wordList.sort().forEach(word => {
        const opt = document.createElement("option");
        opt.value = word;
        opt.textContent = word;
        select.appendChild(opt);
      });
    }

    document.getElementById("word-select").addEventListener("change", function(e) {
      const palabra = e.target.value;
      document.getElementById("select-status").textContent = "";
      if (palabra) {
        const result = classifyWords([palabra]);
        renderResults(result);
        buildComparativeTable(palabra);
        document.getElementById("results-panel").style.display = "block";
        document.getElementById("summary-stats").style.display = "none";
      } else {
        clearTable();
      }
    });

    document.getElementById("input-form").addEventListener("submit", function(e) {
      e.preventDefault();
      const palabra = document.getElementById("input-words").value.trim().toLowerCase();
      const status = document.getElementById("manual-status");
      status.textContent = "";
      if (!palabra) {
        status.textContent = "";
        return;
      }
      if (LEXICON[palabra]) {
        const result = classifyWords([palabra]);
        renderResults(result);
        buildComparativeTable(palabra);
        document.getElementById("results-panel").style.display = "block";
        document.getElementById("summary-stats").style.display = "none";
      } else {
        renderResults([{
          Word: palabra,
          Cluster: "No clasificada",
          "Sub-Cluster": "No clasificada",
          BIS: "",
          Valence_Mean: "",
          Arousal_Mean: "",
          Concreteness_Mean: "",
          Emotionality: "",
          Dominant_emotion: "",
          Zipf_EsPal: "",
          POS: "",
          F1: "",
          found: false
        }]);
        document.getElementById("results-panel").style.display = "block";
        document.getElementById("summary-stats").style.display = "none";
        document.getElementById("comparative-panel").style.display = "none";
        status.innerHTML = `<span class="warn">Palabra no encontrada. Solo se pueden clasificar palabras presentes en el léxico.</span>`;
      }
    });

    function classifyWords(words) {
      return words.map(word => {
        const key = word.toLowerCase();
        const entry = LEXICON[key];
        if (entry) {
          let subCluster = Number(entry["Sub-Cluster"]);
          let F1 = "N/A";
          if (F1_by_subcluster.hasOwnProperty(subCluster)) {
            F1 = F1_by_subcluster[subCluster];
          }
          return {
            Word: word,
            Cluster: entry.Cluster ?? "N/A",
            "Sub-Cluster": subCluster ?? "N/A",
            BIS: entry.Balanced_Integration_Score ?? "",
            Valence_Mean: entry.Valence_Mean ?? "",
            Arousal_Mean: entry.Arousal_Mean ?? "",
            Concreteness_Mean: entry.Concreteness_Mean ?? "",
            Emotionality: entry.Emotionality ?? "",
            Dominant_emotion: entry.Dominant_emotion ?? "",
            Zipf_EsPal: entry.Zipf_EsPal ?? "",
            POS: entry.POS ?? "",
            F1: F1,
            found: true
          };
        } else {
          return {
            Word: word,
            Cluster: "No clasificada",
            "Sub-Cluster": "No clasificada",
            BIS: "",
            Valence_Mean: "",
            Arousal_Mean: "",
            Concreteness_Mean: "",
            Emotionality: "",
            Dominant_emotion: "",
            Zipf_EsPal: "",
            POS: "",
            F1: "",
            found: false
          };
        }
      });
    }

    function renderResults(results) {
      const tbody = document.querySelector("#results-table tbody");
      tbody.innerHTML = "";
      let bisArr = [];
      let f1Arr = [];
      for (const r of results) {
        const tr = document.createElement("tr");
        if (!r.found) {
          tr.innerHTML = `
            <td colspan="12" class="warn">
              "${r.Word}": Palabra no encontrada en la base léxica. No puede ser clasificada automáticamente.
            </td>
          `;
          tr.style.background = "#fbeaea";
        } else {
          tr.innerHTML = `
            <td>${r.Word}</td>
            <td>${r.Cluster}</td>
            <td>${r["Sub-Cluster"]}</td>
            <td>${r.BIS}</td>
            <td>${r.Valence_Mean}</td>
            <td>${r.Arousal_Mean}</td>
            <td>${r.Concreteness_Mean}</td>
            <td>${r.Emotionality}</td>
            <td>${r.Dominant_emotion}</td>
            <td>${r.Zipf_EsPal}</td>
            <td>${r.POS}</td>
            <td>${r.F1}</td>
          `;
          if (!isNaN(r.BIS) && r.BIS !== "") bisArr.push(Number(r.BIS));
          if (!isNaN(r.F1) && r.F1 !== "") f1Arr.push(Number(r.F1));
        }
        tbody.appendChild(tr);
      }
      if (results.length > 1 && bisArr.length > 1) {
        renderStats(bisArr, f1Arr);
        document.getElementById("summary-stats").style.display = "block";
      } else {
        document.getElementById("summary-stats").style.display = "none";
      }
    }

    function clearTable() {
      document.querySelector("#results-table tbody").innerHTML = "";
      document.getElementById("results-panel").style.display = "none";
      document.getElementById("summary-stats").style.display = "none";
      document.getElementById("manual-status").textContent = "";
      document.getElementById("select-status").textContent = "";
      document.getElementById("comparative-panel").style.display = "none";
    }

    // Estadística mínima, usa functions.js si está disponible
    function mean(arr) { return typeof functions !== "undefined" && functions.mean ? functions.mean(arr) : (arr.length ? arr.reduce((a,b) => a+b,0)/arr.length : 0); }
    function sd(arr)   { return typeof functions !== "undefined" && functions.sd   ? functions.sd(arr)   : (arr.length ? Math.sqrt(arr.reduce((a,b)=>a+Math.pow(b-mean(arr),2),0)/arr.length) : 0); }
    function lower_ci(m, s, n) { return typeof functions !== "undefined" && functions.lower_ci ? functions.lower_ci(m, s, n) : (m - 1.96*(s/Math.sqrt(n))); }
    function upper_ci(m, s, n) { return typeof functions !== "undefined" && functions.upper_ci ? functions.upper_ci(m, s, n) : (m + 1.96*(s/Math.sqrt(n))); }

    // PANEL COMPARATIVO BIS POR SUBCLUSTER (con functions.js)
    function buildComparativeTable(selectedWord) {
      const panel = document.getElementById("comparative-panel");
      if (!selectedWord || !LEXICON[selectedWord.toLowerCase()]) {
        panel.innerHTML = '';
        panel.style.display = "none";
        return;
      }
      try {
        const entry = LEXICON[selectedWord.toLowerCase()];
        const cluster = entry.Cluster;
        const subcluster = Number(entry["Sub-Cluster"]);
        let clusterWords = {};
        Object.values(LEXICON).forEach(e => {
          if (e.Cluster == cluster) {
            const sc = Number(e["Sub-Cluster"]);
            if (!clusterWords[sc]) clusterWords[sc] = [];
            clusterWords[sc].push(e);
          }
        });
        let html = `<h4>Comparativa BIS en Clúster ${cluster}</h4>`;
        html += `<table class="emolex-table"><thead><tr>
            <th>Sub-Cluster</th><th>Palabra</th><th>BIS</th>
          </tr></thead><tbody>`;
        Object.entries(clusterWords).forEach(([sc, arr]) => {
          arr.forEach(e => {
            html += `<tr${sc == subcluster ? ' style="background:#e8f8e1;"' : ''}>
              <td>${sc}</td>
              <td>${e.Word}</td>
              <td>${typeof e.Balanced_Integration_Score === "number"
                      ? e.Balanced_Integration_Score.toFixed(5)
                      : e.Balanced_Integration_Score}</td>
            </tr>`;
          });
        });
        html += `</tbody></table>`;
        const bis_target = clusterWords[subcluster].map(e => Number(e.Balanced_Integration_Score)).filter(x=>!isNaN(x));
        let stats_html = `<h4>Análisis de complejidad léxica (BIS)</h4>`;
        Object.entries(clusterWords).forEach(([sc, arr]) => {
          if (Number(sc) !== subcluster) {
            const bis_other = arr.map(e => Number(e.Balanced_Integration_Score)).filter(x=>!isNaN(x));
            if (typeof functions !== "undefined" && functions.mean) {
              const grp1m = functions.mean(bis_target);
              const grp1sd = functions.sd(bis_target);
              const grp1n = bis_target.length;
              const grp2m = functions.mean(bis_other);
              const grp2sd = functions.sd(bis_other);
              const grp2n = bis_other.length;
              const sdpooled = functions.sdpooled(grp1sd,grp1n,grp2sd,grp2n);
              const d = (grp1m - grp2m) / sdpooled;
              const g = functions.gfromd(d, grp1n, grp2n);
              const v = functions.vd(d, grp1n, grp2n);
              const lower = functions.lower_d(d,v);
              const upper = functions.upper_d(d,v);
              stats_html += `<p>
                <b>Diferencia BIS</b> entre Sub-Cluster <b>${subcluster}</b> y <b>${sc}</b>:<br>
                <b>Cohen's d = ${d.toFixed(3)}</b> [IC 95%: ${lower.toFixed(3)}, ${upper.toFixed(3)}], g = ${g.toFixed(3)}<br>
                <span style="font-size:90%">(${grp1n} vs ${grp2n} items comparados)</span>
                <br>${d > 0 ? 'Más complejo' : 'Menos complejo'} que Sub-Cluster ${sc}.
              </p>`;
            } else {
              stats_html += `<p style="color:red">functions.js no está cargado o no tiene funciones estadísticas.</p>`;
            }
          }
        });
        panel.innerHTML = html + stats_html;
        panel.style.display = "block";
      } catch (err) {
        panel.innerHTML = `<span style="color:red">Error en el análisis comparativo: ${err.message}</span>`;
        panel.style.display = "block";
        console.error(err);
      }
    }
  </script>
</body>
</html>
